
1. The MVVM must follow the normal programming scope/context logic
	1.1. Lower code blocks will have access to upper code blocks' variables
	1.2. Variables definitions in lower code blocks will `replace` the variables in the upper code blocks' variables only inside themselves
	1.3. These rules apply recursive to an unrestricted level

2. Functions
	2.1. Will follow the Javascript language logic by default and will have access to upper code blocks' variables (from where they are called)
	2.2. There will be an ability to restrict what variables are accessible via something like `q-use='$var_1, $var_2, ...'`
	2.3. From the config we should be able to restrict access to variables outside the function (by default), `q-use` will still be available

3. HOW
	3.1. All changes are made via the DATA 
	3.2. The DATA elements are always objects, even scalars, with a $val property that hold the actual value
		3.2.1. For objects $val is either undefined, or it points to itself
		3.2.2. For objects arrays $val is either undefined, or it points to (@DECIDE either itself || an Array on a prop like $array)
	3.3. The DATA is setup when expressions are evaluated with `undefined` values
	3.4. We do not re-set the DATA instances (unless for some explicit utility). Once we've instantiated DATA (object,array,scalar) the object
			that contains it will remain as we will have listeners attached to it.
	3.5. One exception, DATA elements can be removed if requested by SET DATA and there are no more watchers 
				(ex: LOOPS (for,while) will remove elements that are only watched by themselves)
	3.6. !!! If we encounted an expression (with any level of depth, ex: products.images[100].src) and it needs to be watched,
			we will SET the DATA for it, even if there is no real DATA and we will set $val(s) to null
			ex: {products: {$val: undefined, images: {$val: undefined, '100': {$val: undefined, 'src': {$val: undefined}}}}}
			this will help us setup watchers even if there is no data
			afterwards, when DATA is set the watchers will be used
	3.7. Isolate the rendering execution in order to be able to delay it on heavy load (for example: no more than once every 100ms)
	3.8. Expressions may also return error (must be run in a try-catch)

4. Expressions
	4.1. In theory we will accept any expression, we will need to review and document the limitations
	4.2. There is a Regex that will split it into tokens
	4.3. Then we will look for indentifiers, even nested (ex: products.images[config.default.index].src) 
	4.4. We will ensure that there is DATA initialized (create it if not present) for them when possible and attach listeners/watchers to the DATA
	4.5. In a more complex example (ex: products.images[config.default.index].src) , 
			we would watch for `config.default.index` and for `products.images` and when any of them changes we would
			attach a watcher to `products.images[config.default.index].src` and re-evaluate
	4.6. In case of dynamic expressions like (ex: products.images[getImagesIndex()].src), the programmer should define a 
			trigger for the changes of the dynamic elements (ex: `getImagesIndex()`)

5. WHILE
	5.1. From a MVVM perspective a WHILE will generate a LIST that will be `watched` for changes
	5.2. On changes this list is re-generated and the VIEW is updated

6. Objectives
	6.1. Able to do most of the work in the declaration, with as much `un-declared` code as possible
	6.2. When linked to RESTFul APIs (or other via a middleware), it must be able to setup a 
			GRID (add/edit/list/view, filter, group by, limit) without extra code
	6.3. URL controller, for usability/SEO
	6.4. `patching` mechanics when adding components/functions
	



SOME NOTES (to be clened up)
<!-- and then we are good to go ! 
				
				define it somehow,
				q-api / q-data-api = how data is pulled
				if (q-api | we don't need q-data) | maybe a q-default
   
				1. [almost done] make sure it's recursive
						this also includes 'includes'
				2. dynamic data pulling
				3. works with some defaults (pre-init server-side)
				4. multiple file support / works on file-component base
				5. stack-able components
				6. [done] cross-referenced data binding
				7. events and middleware to control the flows/what it does/how ... etc ...
				8. [done - events are called after set data] transaction based transforms
				9. setup reusable stuff like: TABS, TREE, etc ... optimized pattern
					ADD FUNCTIONALITY JUST LIKE YOU WOULD ADD CSS CLASSES !
						also: shortcuts for --- add-item/row, delete-item/row = 
				10. Render to server side-code
				11. q-while
						q-while will create an invisible `collection` that will be used as data foreach sub-context
							... it will be all about referencing that data correctly !
				12. [done] able to add DOM that contanins `MVVM` and resync
				13. Utility: SEO helper, replace defs by: "CSS class + JS code in another file"
						ALSO data can/will be loaded from from DOM to MODEL
				14. [done] cross reference data with $root/$parent/$children
				15. [done] for LOOP ... it's a short wrap for WHILE
				16. [done - @todo functions inside expressions] DYNAMIC KEYS: q-for='children[anything.data[1].option].text' or q-for='children[afunction($bar)].text'
				17. Performance Optimizations
			
				Other
					There must be some garbage collectors at some point ! Be careful not to remove data with listeners !
						Remove data when there is no more DOM elements listening
					Context.inside_tpl - may not be needed !!!
			-->

