

# what if we always write ahead ?! - what can go wrong ? - a lot of invalid pages with markings 
# but if we don't care about the order ... we go from last to first ... and update the INDEX with the new location of the data
	# 1. we will need to write down a lot more data ... as NVME has a lot more IOPS ... that may not be desired
	# 2. if in memory for a long time ... writes may be organized as part of the cleanup process as needed 
	# 3. as more writes are buffered, we must have a more linear write plan at some point ... or at least they will bulk in
# we will not always WAL ... if low IO traffic -> on disk

table
	file
		pages (column/position)
			first -> pointer to the first page
			next/prev (pages) / to keep an order by Id

(select columns ... $c1 -> pageX, $c2 -> pageY, ...)
(pages need to stay grouped on the same ID ... somehow)

# main pages
meta: first page, last page | then on each page: prev/next, then each page will know it's group
	: c1 : g1, c2: g1, c3: g2 .... or (page's groups and layout : 3 groups, 1: c1, 2: c2 ....)
	: may also hold first/last per group ... but that would be cached info ?!

PER PAGE: group pos (so it can be recovered)

each page may have a different layout (to be able to re-fit on struct upgrades)
each page must say rowsize, isset per row ... etc

page A1 , page A2, page A3 (rowid is the same)
page B1
page C1

# references -> Category -> point to ID -> then ID to hash | may hold a physical ref ... future
#								(by config: UPDATE ON IDs should not be allowed)

index | index as needed ?!

