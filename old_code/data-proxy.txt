
const DLib_Proxy_Map = new WeakMap();

var DLib_Changes = {};
function DLib_Process_Changes()
{
	console.log('DLib_Process_Changes', DLib_Changes);
	
	for (var $id in DLib_Changes)
	{
		var $node = DLib.nodes[$id];
		if (!$node)
		{
			console.warn('Missing node with Id=' + $id);
			continue;
		}
		$node.handleChanges(DLib_Changes[$id]);
	}
	// reset them after we are done
	DLib_Changes = {};
}

const DProxyHdl = {
	
	get: function(obj, prop) // , proxy)
	{
		// if (Array.isArray(obj) && (isNaN(prop)))
			// return obj[prop];
		// @TOCHECK - see if when prop = length , do we need to watch it or not
		
		// @TODO - we need to fully undestand how & why is this called with `symbol` as property
		if (typeof(prop) === 'symbol')
			return obj[prop];
		
		// @TODO - catch (length = X - to trigger shorter array!)
		var $r = obj[prop];
		if (typeof($r) === 'function')
			return $r;
		else if ((prop[prop.length - 1] === '$') && ((prop === 'p$') || (prop === 'w$$') || (prop === 'w$')))
			return;
		
		console.log('get (obj, prop[' + typeof(prop) + '] = `' + ((typeof(prop) === 'symbol') ? prop.description : prop) + '`) | obj = ', obj);
		// tick any global watchers DLib._wt
		var $is_obj = (typeof($r) === 'object') && ($r !== null);
		if (DLib._wt)
		{
			var $w, $w_map;
			if ($is_obj) // the watch will be on obj[prop].w$$
				($w_map = $r.w$$) ? $w_map : ($w_map = $r.w$$ = {});
			else
				($w_map = (($w = obj.w$) ? $w : ($w = obj.w$ = {}))[prop]) ? $w_map : ($w_map = $w[prop] = {});
			// @TODO how do we cleanup `out of scope` watchers | list per expression, on second run, all not touched are to be removed
			for (var $i = 0; $i < DLib._wt.length; $i++)
			{
				var $watch = DLib._wt[$i];
				var $has_el = $w_map[$watch[0]];
				if ($has_el) // is an array
					Object.assign($has_el, $watch[1]);
				else
					$w_map[$watch[0]] = $watch[1];
			}
		}
		
		/*
		if (typeof($r) === 'function')
		{
			// making sure we return a proxy ... does it help in any way ?!
			return function (...args) {
				let result = origMethod.apply(this, args);
				console.log(propKey + JSON.stringify(args)
					+ ' -> ' + JSON.stringify(result));
				return result;
			};
		}
		else */
		return $is_obj ? $r.p$ : $r;
	},
	
	set: function(obj, prop, value) // , proxy)
	{
		if (typeof(prop) === 'symbol')
		{
			console.log(prop, Symbol.for(prop), Symbol.keyFor(prop));
			alert('sym');
		}
		
		if (typeof(value) === 'function')
			throw Error('Setting a function is not supported atm');
		else if ((prop[prop.length - 1] === '$') && ((prop === 'p$') || (prop === 'w$$') || (prop === 'w$')))
			return true;
		// it can be a foreign object
		console.log('set (obj, prop[' + typeof(prop) + '] = `' + ((typeof(prop) === 'symbol') ? prop.description : prop) + '`) ' + 'value = ', value, ' | obj = ', obj);
		// obj[prop] = value;
			
		var $old = obj[prop];
		if ($old === value)
			// no change
			return true;
		var $new;
		
		if ((typeof(value) === 'object') && (value !== null))
		{
			var $m_val = DLib_Proxy_Map.get(value) || value;
			if ($m_val !== value)
				value = $m_val;
			
			if ((!$old) || (typeof($old) !== 'object') || ($old.p$ === undefined))
			{
				if (Array.isArray(value))
				{
					$new = [];
					var $proxy = $new.p$ = new Proxy($new, DProxyHdl_Array);
					for (var $i = 0; $i < value.length; $i++)
						$proxy[$i] = value[$i];
				}
				else
				{
					$new = {};
					var $proxy = $new.p$ = new Proxy($new, DProxyHdl);
					for (var $i in value)
						$proxy[$i] = value[$i];
				}
				if ((typeof($old !== 'object')) && obj.w$ && obj.w$[prop])
				{
					// @TODO - we need to review how we set the listeners/watchers !!! !!!
					// move watchers to the instance of the new object
					$new.w$$ = obj.w$[prop];
					// for some reason, this breaks the FOR loop !!!
					// delete obj.w$[prop];
				}
				DLib_Proxy_Map.set($new.p$, $new);
			}
			else
				$new = value;
		}
		else
			$new = value;
		
		var $watchers = Array.isArray(obj) ? (obj.w$$) : (((typeof($old) === 'object') && ($old !== null)) ? $old.w$$ : (obj.w$ ? obj.w$[prop] : null));
		// console.log('$watchers', $watchers, obj, prop, value);
		if ($watchers)
		{
			// console.log('$watchers', $watchers);
			for (var $id in $watchers)
			{
				var $wtch = $watchers[$id];
				var $dli = DLib_Changes[$id];
				if ($dli)
					Object.assign($dli, $wtch);
				else
					DLib_Changes[$id] = $wtch;
			}
			
			// this is one way to wait for the current tasks to be finished before we make an update, then the update should clear the changes
			// @TODO - is there a better way to do this ?!
			setTimeout(DLib_Process_Changes, 1);
		}
		
		obj[prop] = $new;
		return true;
	},
	
	has: function(obj, prop)
	{
		if (typeof(prop) === 'symbol')
		{
			console.log(prop, Symbol.for(prop), Symbol.keyFor(prop));
			alert('has :: sym');
		}
		console.log('has (obj, prop[' + typeof(prop) + '] = `' + ((typeof(prop) === 'symbol') ? prop.description : prop) + '`) | obj = ', obj);
		// @TODO - we need to decide what we allow!
		return (prop !== "console");
	}
	
	// deleteProperty: function(target, property) { console.log("Deleted %s", property); return true; },
	
	// has: function(target, prop) { return prop in target; }
	
	// not used atm
	// ownKeys (target) { return Reflect.ownKeys(target) }
};

// function DObj(){}
// Object.defineProperty(DObj.prototype, 'p$', {enumerable: false}); // proxy

const DProxyHdl_Array = {
	
	get: DProxyHdl.get,
	set: DProxyHdl.set,
	has: DProxyHdl.has
};
/*
var $t1 = new Date();
var $proxy = new Proxy({}, DProxyHdl);
$proxy.data = $data_to_test;
var $t2 = new Date();

var $watcher = new DNode();
$watcher.id = 1;

DLib._wt = [[$watcher.id, {each: true, if: true}]];

var $res = null;

// console.log('before sort');

// $proxy.data.children[0] = 1;
// $proxy.data.children.sort((a, b) => a - b);

$res = $proxy.data.children.filter((item) => parseInt(item.text.match(/\d+/))%2);

// console.log('middle');

$res = $res.sort((a, b) => (a.text !== b.text ? a.text < b.text ? 1 : -1 : 0));

// alert($t2 - $t1);
// console.log('AFTER sort');

$proxy.data.children.push({text: 'the new kid in town!'});


// alert('we are done! in: ' + ($t2 - $t1));

$data_to_test = JSON.parse( JSON.stringify($proxy.data) );

// console.log('$proxy', $proxy.data.children, $res);

// alert($t2 - $t1);
*/

/*
// THIS IS GOLDEN !!!
function not_used_at_all__()
{
	const handler = {
	  get: function(obj, prop) {
		  // console.log(prop);
		  // console.log('get (obj, prop = `' + prop + '`)');
		  return (($op = obj[prop]) === null) ? null : ((typeof($op) === 'object') ? new Proxy($op, handler) : $op);
	  },
	  set: function(obj, prop, value) {
		  console.log('set (obj, prop = `' + prop + '`, value = `' + value + '`)');
		  obj[prop] = value;
	  }
	};

	var $obj = {};
	var $obj_2 = {};

	const p = new Proxy($obj, handler);
	p.a = 1;
	// p.b = undefined;

	const x = new Proxy($obj_2, handler);
	x.b = 2;

	function testit(x)
	{
		console.log(x, this, arguments);
	}

	// (new testit(p.a));
	console.log('p.a - before', p.a);
	// console.log(p);
	with (x)
	{
		console.log('x.b', b);
		b = 12;
	}

	console.log('p.a - after', p.a);
	console.log('x.b - after', x.b);

	alert('hoo!');
}
*/
