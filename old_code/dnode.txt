
class DNode
{
	constructor()
	{
		this.dom = undefined;
		this.parent = undefined;
		this.children = undefined;
		this.attrs = undefined;
		this.is_loop = false;
		this.is_root = false;
		this.is_tpl = false;
		this._new_ctx = undefined;
		this.inside_tpl = false;
		this.data = undefined;
		this._obj = undefined;
		this.data_key = undefined;
		this.local_vars = undefined;		
	}
	
	/**
	 * 
	 * @param {HTMLElement} $dom
	 * @param {DNode} $parent
	 * @param {object} $attrs
	 * @param {String} $role
	 * 
	 * @returns {undefined}
	 */
	init ($dom, $parent, $attrs, $role)
	{
		if (!$dom)
			throw new Error('The `$dom` argument is mandatory');
		
		if ($dom.__ctx)
		{
			console.warn($dom);
			throw new Error('Trying to init DNode on an already existing one!');
		}
		
		// update idx_dom
		$dom.__ctx = this;
		this.dom = $dom;
		this.children = [];
		this.attrs = $attrs ? $attrs : (($attrs = this.dom_get_attrs($dom)) ? $attrs : {});
		// parent init here
		this.is_root = ($parent ? false : true);
		this.parent = $parent ? $parent : null;
		$parent ? $parent.children.push(this) : null;
		
		this.is_tpl = ($dom.tagName === 'TEMPLATE');
		
		if (this._new_ctx === undefined)
			this._new_ctx = this.is_root || (!this.parent);
		if (this._new_ctx && (!this.local_vars))
			this.local_vars = {};

		// in contex only data init
		this.init_data(DLib.$root);

		// setup the expressions
		this.init_exps();

		// link key info to the data
		if (this.with_key)
		{
			if (!(this._each_as && this._each_as[0]))
				throw new Error('A `each` was defined with a key but there is no item var name');
			if (!this.eachDataRef)
				throw new Error('A `each` was defined with a key but there is no reference to the collection');
			if (!this.each_key_obj)
				throw new Error('A `each` was defined with a key but there is no function defined for it');

			this.each_key_obj = new Function(this._each_as[0], '$index', this.each_key_obj);
			this.each_key = new Function(this._each_as[0], '$index', this.each_key);

			if (this.eachDataRef.$each_key && (this.eachDataRef.$each_key.toString() !== this.each_key_obj.toString()))
				throw new Error('Two or more `each` are defined with a key but the keys are not identical');

			this.eachDataRef.$each_key = this.each_key_obj;
		}

		// scan dom for more mvvm
		this.init_dom(this.dom);
		
		// @TODO - on initial boot : non-templates to be copied inside templates, extract DATA from DOM
		if (!this.is_tpl)
		{
			if (this.attrs['q-data'])
			{
				var $q_data = eval("( " + this.dom.getAttribute('q-data') + " )");
				this.setData($q_data);
			}
		}
	}
	
	dom_get_attrs($node)
	{
		var $ctx_attrs = null;
		for (var $k = 0; $k < $node.attributes.length; $k++)
		{
			// @TODO - make this configurable
			var $attr = $node.attributes[$k];
			var $has_q_prefix = false;
			if (($attr.name[0] === ':') || ($has_q_prefix = ($attr.name.substr(0, 2) === 'q-')))
			{
				if (!$ctx_attrs)
					$ctx_attrs = {};
				$ctx_attrs[$attr.name] = $attr.value;
				if ($has_q_prefix && (!DLib.q_attrs_list.includes($attr.name)))
					console.warn('unknown attribute name: `' + $attr.name + '` on node: ', $node);
			}
		}
		
		return $ctx_attrs;
	}
	
	/**
	 * 
	 * @param {HTMLElement} $node
	 * @returns {undefined}
	 */
	init_dom($node)
	{
		if ($node.tagName === 'TEMPLATE')
			// no need to init inside a TEMPLATE
			return;

		var $children;
		if (! ($node && (($node.tagName === 'TEMPLATE') ? ($children = $node.content.children) : ($children = $node.children))))
			return;
		
		for (var $i = 0; $i < $children.length; $i++)
		{
			var $el = $children[$i];
			if ($el.__ctx)
				continue;
			var $ctx_attrs = this.dom_get_attrs($el);
			var $el_ctx = $ctx_attrs ? (new DNode()) : null;
			if ($el_ctx)
				// inside init it will continue `init_dom`
				$el_ctx.init($el, this, $ctx_attrs);
			else
				this.init_dom($el);
		}
	}
	
	/**
	 * 
	 * @param {String} $var_name
	 * @returns {object}
	 */
	setupVariable($var_name)
	{
		var $ret = this._obj[$var_name];
		if ($ret)
			return $ret;
		else if (this.is_root || (this.local_vars && this.local_vars[$var_name]))
			return (this._obj[$var_name] = {});
		else if (!this.parent)
			throw Exception('Element is missing parent and it\'s not root');
		else
			return (this._obj[$var_name] = this.parent.setupVariable($var_name));
	}
	
	/**
	 * 
	 * @param {String} $expression
	 * @param {String} $attr_name
	 * @param {Array} $callback_def
	 * @param {Integer} $offset
	 * @param {Array} $new_tokens
	 * 
	 * @returns {Function}
	 */
	setupExp($expression, $attr_name, $callback_def, $offset, $new_tokens)
	{
		// 1. tokenize, 2. for all identifiers, setupIdentifiers !
		// atm we just make a split
		var $identifier_only = true;
		var $was_init = false;
		if (!$offset)
		{
			$offset = {value: 0};
			$was_init = true;
		}
		
		// regular expressions cache
		var $rx_cache = (DLib.$root._regex_cache ? DLib.$root._regex_cache : (DLib.$root._regex_cache = {}));
		var $tokens = (typeof($expression) === 'string') ? 
					($rx_cache[$expression] ? $rx_cache[$expression] : ($rx_cache[$expression] = $expression.match($Regex))) : $expression;
		
		$new_tokens = ($new_tokens ? $new_tokens : []);
		// $idf_parts ex : children[0].child.text | @TODO (??variables in identifiers) || it means DYNAMIC KEYS ... identifier in identifier => nested watching ?!
		var $last_idf_type = null;
		
		var $start_offset_new = $new_tokens.length;
		// THIS NEEDS TO BE RECURSIVE IN ORDER TO SUPPORT DYNAMIC IDENTIFIERS !!!
		var $current_data = this._obj;
		var $is_static_expr = true;
		
		while ($offset.value < $tokens.length)
		{
			var $token = $tokens[$offset.value];
			var $token_0 = $token[0];
			
			// skip whitespace
			if (($token_0 === ' ') || ($token_0 === "\n") || ($token_0 === "\t") || ($token_0 === "\r")) { $new_tokens.push($token); }
			// an identifier
			else if ($token[0].match(/^(?:[^\d\W]|\$)$/) && ($Keywords[$token] === undefined))
			{
				$is_static_expr = false;
				if ($last_idf_type === null)
				{
					// we need to identify the variable
					if (!$current_data[$token])
						$current_data[$token] = this.setupVariable($token);
					
					$new_tokens.push('$this', '.');
				}
				else if (!$current_data[$token])
				{
					$current_data[$token] = {};
				}
				$new_tokens.push($token);
				
				$current_data = $current_data[$token];
				$last_idf_type = true;
				($current_data.$w ? $current_data.$w : ($current_data.$w = [])).push($callback_def);
			}
			else if ($last_idf_type !== null)
			{
				if ($token === '.')
				{
					$new_tokens.push('.');
					$last_idf_type = '.';
				}
				else if ($token === '[')
				{
					if ($last_idf_type !== true)
						throw new Error('Parse error. Expected identifier before `[` ' + $expression);
					$new_tokens.push('[');
					$offset.value++;
					
					var $tmp_exp_ret = this.setupExp($expression, $attr_name, $callback_def, $offset, $new_tokens);
					var $exp_func = $tmp_exp_ret[0];
					alert('@TODO, setup $identifier_only based on $exp_func (if static string/int ... ok, else ... bad): ' + typeof($exp_func));
					// if ((typeof($exp_func) === 'string') || (typeof($exp_func) === 'number'))
					//	$identifier_only = false;
					
					if ((typeof($exp_func) === 'string') || (typeof($exp_func) === 'number'))
					{
						// the identifier is static ... we can do our default way
						// $new_tokens.push($exp_func);
						if (!$current_data[$exp_func])
							$current_data[$exp_func] = {};
						$current_data = $current_data[$exp_func];
						($current_data.$w ? $current_data.$w : ($current_data.$w = [])).push($callback_def);
					}
					else
					{
						// @TODO ... test binding in these cases !!!
						// alert(typeof($exp_func) + "\n\n" +  $exp_func);
						$identifier_only = false;
					}
					
					$new_tokens.push(']');
					
					$last_idf_type = '[]';
				}
				else if ($token === ']')
				{
					$new_tokens.push('.', '$val');
					$last_idf_type = null;
					// we jump out of setupExp
					break;
				}
				else if (($token[0] === '"') || ($token[0] === '\'') || (($token.charCodeAt(0) >= $Digit_Min) && ($token.charCodeAt(0) <= $Digit_Max)))
				{
					// if ($last_idf_type !== '[')
						// throw new Error('Parse error. Expected `[` before identifier(`' + $token + '`) ' + $expression);
					$new_tokens.push($token);
					$last_idf_type = null;
					$current_data = this._obj;
				}
				else
				{
					$last_idf_type = null;
					$current_data = this._obj;
					// end the identifier with 
					$new_tokens.push('.', '$val');
					$new_tokens.push($token);
				}
			}
			else if ($token === ']')
			{
				// we jump out of setupExp
				break;
			}
			else
			{
				$new_tokens.push($token);
				// @TODO - we need to test more cases
				$identifier_only = false;
			}
			
			$offset.value++;
		}
		
		if ($last_idf_type !== null)
			$new_tokens.push('.', '$val');
			
		// this.setupIdentifiers($idf_parts, null, $callback_def);
		if ($was_init)
		{
			// 
		}
		
		if ($is_static_expr)
		{
			var $ret;
			try
			{
				$ret = eval("(" + ($new_tokens.slice($start_offset_new).join('')) + ");");
			}
			catch ($ex)
			{
				throw new Error('Failed to evaluate static expression: ' + $tokens.join(''));
			}
			return [$ret, $identifier_only, $current_data];
		}
		else
		{
			return [(new Function([], 'var $this = this._obj; return ' + $new_tokens.slice($start_offset_new).join('') + '; ')),
						$identifier_only, $current_data];
		}
	}
	
	expChanged($event, $args)
	{
		var $what = $args[0];
		
		if ($what === 'if')
		{
			var $result = this.exp_if.apply(this, []) ? true : false;
			if ($result !== this.__if_result)
			{
				this.__if_result = $result;
				
				if ($result && (!this.__if_child))
				{
					// things are now positive !
					if (this.dom.tagName === 'TEMPLATE')
					{
						// we need to clone
						var $clone = this.dom.content.cloneNode(true);
						var $first_child = $clone.firstElementChild;
						$clone.firstElementChild.__if_tag = this;
						this.dom.parentNode.insertBefore($clone, this.dom.nextSibling);
						
						var $html_ctx = new DNode();
						$html_ctx.init($first_child, (this.dom.tagName === 'TEMPLATE') ? this.parent : this);
						this.__if_child = $html_ctx;
					}
					else
					{
						// @TODO ... in non-template mode the parent may be 'this' , instead of 'this.parent'
					}
				}
			}
		}
		else if ($what === 'each')
		{
			/**
			 * Logic should be:
			 *		OPS_DF = new DocumentFragment
			 *		OPS_DF_LEN = 0	// we keep a cache for it
			 *		OPS_DF_FIRST_ELEM = null // we keep a cache for it
			 *		OPS_DF_INSERT_AFTER = null
			 *		Foreach NEW_LIST as POS => NEW_ELEMENT
			 *			IF NEW_ELEMENT.KEY = OLD_LIST[POS].KEY
			 *			{
			 *				IF (OPS_DF_LEN > 0)
			 *				{
			 *					INSERT OPS_DF after LAST_NODE
			 *					LAST_NODE = last element in OPS_DF
			 *				}
			 *				ELSE
			 *					LAST_NODE = OLD_LIST[POS]
			 *			}
			 *			ELSE
			 *				IF OLD_LIST CONTAINS KEY 
			 *						MOVE OLD_LIST[KEY] INSIDE THE OPS_DF 
			 *						SET (OPS_DF_INSERT_AFTER = LAST_NODE)
			 *				ELSE (OLD_LIST DOES NOT CONTAINS KEY)
			 *						CREATE CLONE AND PUSH IT INSIDE THE OPS_DF 
			 *						
			 *		ALL ELEMENTS REMAINING MUST BE CLEANED & REMOVED 
			 */
			
			if (!this.__each_child)
				this.__each_child = [];
			if (!this._key_map)
				this._key_map = {};

			var $virtual_list = this.exp_each.apply(this, []);
			if (($virtual_list === null) || ($virtual_list === undefined))
				$virtual_list = {$length: 0};
			
			if (this.with_key)
			{
				// we need to enforce positioning, while having correct keys!
				var $this_each_pos = 0;
				if (!this.__each_map)
					this.__each_map = {};
				
				var $dom_pending_frag = document.createDocumentFragment();
				// var $dom_moved_frag = {};
				
				var $new_each_child = [];
				var $new_each_map = {};
				var $insert_before = this.dom.nextSibling;
				
				var $reused = {};

				for (var $i = 0; $i < $virtual_list.$length; $i++)
				{
					var $key = this.each_key($virtual_list[$i], $i);
					
					// make sure we skip no-longer-needed elements from $this_each_pos to the first one still being used, or elements that have already been used
					while (($this_each_pos < this.__each_child.length) && 
							($reused[$this_each_pos] || 
							(($virtual_list.$each_index[this.__each_child[$this_each_pos].map_key]) === undefined)))
					{
						DLib.log('Skipping ' + ($reused[$this_each_pos] ? 'reused' : 'non-existing') + ' child : [$this_each_pos = ' + $this_each_pos + '] ;' + 
										' [map_key = ' + this.__each_child[$this_each_pos].map_key.replace(/(?:\r\n|\r|\n)/g, ' | ') + ']');
						$this_each_pos++;
					}
					
					// do we have it at the current position ?
					var $child_pos = this.__each_map[$key];
					var $child_node = ($child_pos !== undefined) ? this.__each_child[$child_pos] : null;
					if ($child_node)
						$reused[$child_pos] = true;
					$new_each_map[$key] = $i;
					
					if ($child_pos === undefined)
					{
						// new node, create it and add it to the doc fragment
						var $item_node = this.createLoopNode($i, $dom_pending_frag, $virtual_list[$i]);
						$new_each_child[$i] = $item_node;
						DLib.log('Adding node to DOM Fragment [key=' + $key + ']');
					}
					else if ($child_pos !== $this_each_pos)
					{
						// existing node, but not in the right place
						$dom_pending_frag.appendChild($child_node.dom);
						$new_each_child[$i] = $child_node;
						DLib.log('Move existing node to DOM Fragment [key=' + $key + ']');
					}
					else
					{
						// leave it where it is
						if ($dom_pending_frag.children.length > 0)
						{
							// insert any pending nodes before it
							$child_node.dom.parentNode.insertBefore($dom_pending_frag, $child_node.dom);
							DLib.log('Insert/flush pending DOM Fragment before [key=' + $key + ']');
						}
						
						$new_each_child[$i] = $child_node;
						$this_each_pos++;
						$insert_before = $child_node.dom.nextSibling;
						DLib.log('NO OOP, node is in the right order [key=' + $key + ']');
					}
					
					$new_each_child[$i].map_key = $key;
				}
				
				if ($dom_pending_frag.children.length > 0)
				{
					this.dom.parentNode.insertBefore($dom_pending_frag, $insert_before);
					DLib.log('Insert/flush [after loop] pending DOM Fragment before [key=' + $key + ']');
				}
				
				// remove any extra elements
				for (var $i = $this_each_pos; $i < this.__each_child.length; $i++)
				{
					if (!$reused[$i])
					{
						var $old_el = this.__each_child[$i];
						$old_el.dom.remove();
					}
				}
				
				this.__each_child = $new_each_child;
				this.__each_map = $new_each_map;
			}
			else
			{
				var $dom_frag = document.createDocumentFragment();
				// we match elements by position
				if (this.__each_child.length > $virtual_list.$length)
				{
					// we need to remove elements
					for (var $i = $virtual_list.$length; $i < this.__each_child.length; $i++)
					{
						var $old_el = this.__each_child[$i];
						$old_el.dom.remove();
					}
					// remove extra elements @TODO - a proper cleanup
					this.__each_child.length = $virtual_list.$length;
				}
				else if (this.__each_child.length < $virtual_list.$length)
				{
					var $last_element = (this.__each_child.length > 0) ? this.__each_child[this.__each_child.length - 1].dom : this.dom;
					// we need to add elements
					for (var $i = this.__each_child.length; $i < $virtual_list.$length; $i++)
					{
						this.__each_child[$i] = this.createLoopNode($i, $dom_frag, $virtual_list[$i]);
					}
					
					this.dom.parentNode.insertBefore($dom_frag, $last_element.nextSibling);
				}
			}
		}
		else if ($what === 'call')
		{
			// this.exp_call | as an array !
			var $func_dom = DLib.functions[this.call_method];
			// get call args
			// var $call_args = [];
			var $local_vars = {};
			var $call_params = {};
			
			// alert('expChanged q-call: ' + (this.exp_call.items[2] === DLib.$root._obj.items));
			
			/*var $debug = this.attrs['q-func'] === undefined;
			if ($debug)
			{
				alert('dbg: ' + this.call_args);
			}*/
			
			for (var $i in this.call_args)
			{
				$local_vars[$func_dom.func_args[$i]] = $func_dom.func_args[$i];
				var $exp_info = this.exp_call[this.call_args[$i]];
				if ($exp_info[1]) // identifier only
				{
					if (!$exp_info[2])
						throw Error('The expression is identifier only but no data was set for it!');
					$call_params[$func_dom.func_args[$i]] = $exp_info[2];
				}
				else
				{
					alert('@TODO dynamic expressions!');
					throw Error('@TODO dynamic expressions!');
					$call_params[$func_dom.func_args[$i]] = this.exp_call[this.call_args[$i]].apply(this, []);
				}
			}
			
			var $html_ctx = this._call_node ? this._call_node : null;
			
			if (!$html_ctx)
			{
				var $html_ctx = new DNode();
				this._call_node = $html_ctx;

				var $clone = $func_dom.dom.content.cloneNode(true);
				var $first_child = $clone.firstElementChild;
				$clone.firstElementChild.__call_tag = this;
				this.dom.parentNode.insertBefore($clone, this.dom.nextSibling);

				$html_ctx.local_vars = $local_vars;
				$html_ctx._new_ctx = true;
				$html_ctx._obj = {};
				for (var $i in $call_params)
					$html_ctx._obj[$i] = $call_params[$i];
				
				$html_ctx.init($first_child, (this.dom.tagName === 'TEMPLATE') ? this.parent : this);
			}
		}
		else if ($what === 'text')
		{
			var $result = this.exp_text.apply(this, []);
			if (this.dom.textContent !== $result)
				this.dom.textContent = $result;
		}
		else if ($what === '@attr-bind')
		{
			var $attr_name = $args[1];
			var $result = this.exp_attr[$attr_name].apply(this, []);
			if (($result !== undefined) && ($result !== null))
				this.dom.setAttribute($attr_name.substr(1), $result);
		}
	}
	
	createLoopNode($index, $dom_frag, $item_data)
	{
		var $i = $index;
		if (this.dom.tagName === 'TEMPLATE')
		{
			// we need to clone
			var $clone = this.dom.content.cloneNode(true);
			var $first_child = $clone.firstElementChild;
			$clone.firstElementChild.__each_tag = this;

			if ($dom_frag)
				$dom_frag.appendChild($clone);

			var $html_ctx = new DNode();
			$html_ctx.is_each_item = true;
			$html_ctx.data_key = $i;
			$html_ctx.local_vars = {};
			// $html_ctx._new_ctx = true;
			$html_ctx.local_vars[this._each_as[0]] = this._each_as[0];
			$html_ctx._obj = {};
			$html_ctx.dom = $first_child;
			$html_ctx._obj[this._each_as[0]] = $item_data;
			// this.__each_child[$i] = $html_ctx;
			$html_ctx.init($first_child, (this.dom.tagName === 'TEMPLATE') ? this.parent : this);
		}
		else
		{
			throw Error('@TODO each clone without a TEMPLATE');
		}
		
		return $html_ctx;
	}
	
	setData($value, $key, $relative_to_data, $trigger_events, $initial_call, $events_bag, $extra_inf)
	{
		if ($trigger_events === undefined)
			$trigger_events = true;
		if ($events_bag === undefined)
			$events_bag = [];
		
		var $data = $relative_to_data ? $relative_to_data : this._obj;
		if ($key === undefined)
		{
			if (($value === null) || ($value === undefined))
			{
				if ($data.$val !== $value)
				{
					$data.$val = $value;
					if ($data.$w)
						$events_bag.push([$data.$w, 'unset', $data]);
				}
			}
			else if (typeof($value) === 'object')
			{
				for (var $k in $value)
				{
					if ($k[0] === '$')
						continue;
					this.setData($value[$k], $k, $relative_to_data, $trigger_events, false, $events_bag);
				}
				
				// return $data;
			}
		}
		else
		{
			var $c_data = $data[$key] ? $data[$key] : ($data[$key] = {});

			if (($value === null) || ($value === undefined))
			{
				if ($c_data.$val !== $value)
				{
					$c_data.$val = $value;
					// ($c_data.$w ? $c_data.$w : []).forEach($e => $e[1].apply($e[2], $e[0]));
					if ($c_data.$w)
						$events_bag.push([$c_data.$w, 'unset', $c_data]);
				}
			}
			else if (Array.isArray($value) || ($value.$length))
			{
				var $has_changes = false;
				if (($c_data.$val !== $c_data) || ($c_data.$type !== 'array'))
				{
					$c_data.$val = $c_data;
					$c_data.$type = 'array';
					$has_changes = true;
				}
				var $current_length = $c_data.$length ? $c_data.$length : 0;
				var $ev_bag = [];
				
				// unset missing values
				var $c_key_cb = $c_data.$each_key;
				var $existing_pos = $c_key_cb ? {} : undefined;
				if ($c_key_cb && (!$c_data.$each_index))
					$c_data.$each_index = {};
				var $new_index = {};
				var $d_pos = undefined;
				
				if ($c_key_cb)
				{
					// we need to map any reusable items
					for (var $i = 0; $i < $value.length; $i++)
					{
						var $v_key = $c_key_cb($value[$i], $i);
						$new_index[$v_key] = $i;
						if ($c_data.$each_index && (($d_pos = $c_data.$each_index[$v_key]) !== undefined))
							$existing_pos[$i] = [$d_pos, $c_data[$d_pos]];
					}
				}
				
				for (var $i = 0; $i < $value.length; $i++)
				{
					if ($c_key_cb)
					{
						var $old_itm = $existing_pos[$i];
						if (!$old_itm)
						{
							// new item, force new
							$c_data[$i] = {};
							$has_changes = true;
						}
						else if ($old_itm[0] !== $i)
						{
							// move it to the right position
							$c_data[$i] = $old_itm[1];
							$has_changes = true;
						}
					}
					this.setData($value[$i], $i, $c_data, $trigger_events, false, $ev_bag, $extra_inf);
				}
				
				if ($value.length < $current_length)
				{
					for (var $i = $value.length; $i < $current_length; $i++)
					{
						// unset
						this.setData(undefined, $i, $c_data, $trigger_events, false, $ev_bag, $extra_inf);
						if ($c_key_cb)
							// we also need to undefine
							delete $c_data[$i];
						$has_changes = true;
					}
				}
				
				if ($current_length !== $value.length)
				{
					$c_data.$length = $value.length; // @TODO - for merge & misc not ok !!!
					$c_data.length = {length: $value.length}; // @TODO - for merge & misc not ok !!!
					$has_changes = true;
				}
				
				if ($c_key_cb && $has_changes)
					$c_data.$each_index = $new_index;
			
				if ($has_changes && $c_data.$w)
					$events_bag.push([$c_data.$w, 'set', $c_data]);
				
				if ($ev_bag.length > 0)
					$events_bag.push(...$ev_bag);
			}
			else if (typeof($value) === 'object')
			{
				if (($c_data.$val !== $c_data) || ($c_data.$type !== 'object'))
				{
					$c_data.$val = $c_data;
					$c_data.$type = 'object';
					if ($c_data.$w)
						$events_bag.push([$c_data.$w, 'set', $c_data]);
				}
				var $ev_bag = [];
				for (var $i in $value)
				{
					if ($i[0] === '$')
						continue;
										
					this.setData($value[$i], $i, $c_data, $trigger_events, false, $ev_bag);
					// @TODO - add events like: add/unset
					if ($c_data.$w && (! ($c_data[$i] && $c_data[$i].$val ))) // we need to do this better !!!
						$events_bag.push([$c_data.$w, 'add', $c_data, $i]);
				}
				if ($ev_bag.length > 0)
					$events_bag.push(...$ev_bag);
			}
			else
			{
				$c_data.$type = typeof($value);
				$c_data.$val = $value;
				// ($c_data.$w ? $c_data.$w : []).forEach($e => $e[1].apply($e[2], $e[0]));
				if ($c_data.$w)
					$events_bag.push([$c_data.$w, 'set', $c_data]);
			}
		}
		if (($initial_call === undefined) || $initial_call)
		{
			if ($trigger_events && $events_bag)
			{
				for (var $i = 0; $i < $events_bag.length; $i++)
				{
					// 0: watchers , 1: action, 2: object
					var $ev = $events_bag[$i];
					var $watchers = $ev[0];
					for (var $k = 0; $k < $watchers.length; $k++)
						$watchers[$k][1].apply($watchers[$k][2], [{}, $watchers[$k][0]]);
				}
			}
		}
	}
		
	/**
	 * This method will only init the DNode's data object
	 * 
	 * @param {DNode} $root
	 * @returns {undefined}
	 */
	init_data($root)
	{
		if (this.attrs['q-data-ref'])
			// you will need to link this._obj to that
			throw new Error('@TODO - reference a DNode\'s data to another DNode\s data');
		
		if (!$root)
			$root = Lib.$root;
		if (!$root)
			throw Error('Missing Lib.$root');
		
		// init data
		{
			if (!this._obj)
			{
				if (this._new_ctx)
				{
					this._obj = {};
					this._obj.$val = this._obj;
				}
				else
					this._obj = this.parent._obj;
			}
			if (!this._obj.$children)
				this._obj.$children = {};
		}
		
		if (this.parent)
		{
			this._obj.$parent = this.parent._obj;
			this._obj.$root = $root._obj;

			// do we need this ?!
			this.parent._obj.$children[this.data_key] = this._obj;
		}
	}
		
	init_exps()
	{
		for (var $_k in this.attrs)
		{
			var $val = this.attrs[$_k];
			var $k = (($_k[0] === ':') && ($_k !== ':key')) ? '@attr-bind' : $_k;
			
			switch ($k)
			{
				case 'q-ctrl':
				case 'q-init':
				case 'q-data':
				case 'q-while':
				{
					// @TODO
					break;
				}
				case 'q-call':
				case 'q-func':
				{
					var $tmp = $val.split(/\s*[\(\)]\s*/g); // use the parser instead !
					var $method = $tmp[0];
					var $expressions = $tmp.slice(1).filter($e => ($e.length > 0));
					
					if ($k === 'q-func')
					{
						this.func_method = $method;
						this.func_args = $expressions;
						DLib.functions[$method] = this;
					}
					else if ($k === 'q-call')
					{
						// @TODO - make sure the function exists, call it async if not
						if ($val.length === 0)
						{
							// empty call to setup with a q-func
							if (!this.func_method)
								throw new Error('Empty q-call must be paired with a q-func');
							$method = this.func_method;
							$expressions = this.func_args;
						}
						
						this.call_method = $method;
						this.call_args = $expressions;
						
						this.exp_call = {};
						for (var $i = 0; $i < $expressions.length; $i++)
							this.exp_call[$expressions[$i]] = this.setupExp($expressions[$i], $k, [['call'], this.expChanged, this]);
						
						// so ... for q-call ... we will need to trigger a data update
						this.expChanged(null, ['call']);
					}
					
					break;
				}
				case 'q-if':
				{
					var $tmp_ret = this.setupExp($val, $k, [['if'], this.expChanged, this]);
					this.exp_if = $tmp_ret[0];
					// this.expr_for_if = $expr_for_if;
					this.expChanged(null, ['if']);
					break;
				}
				case 'q-each':
				{
					/* ex: foreach (children as child) 
								this element will be watching `children`
								each DNode instance created will translate (child => $parent.children[KEY]) when setting up data
					*/
					var $tmp = $val.split(/\s+as\s+/); // use the parser instead !
					// function ($expression, $attr_name, $dom)
					var $tmp_ret = this.setupExp($tmp[0], 'q-each', [['each'], this.expChanged, this]);
					this.exp_each = $tmp_ret[0];
					this.eachDataRef = $tmp_ret[2];
					
					this._each_as = [$tmp[1], $tmp[0]];
					this.expChanged(null, ['each']);
					
					break;
				}
				case 'q-text':
				{
					var $tmp_ret = this.setupExp($val, $k, [['text'], this.expChanged, this]);
					this.exp_text = $tmp_ret[0];
					this.expChanged(null, ['text']);
					break;
				}
				case '@attr-bind':
				{
					if (!this.exp_attr)
						this.exp_attr = {};
					var $tmp_ret = this.setupExp($val, $_k, [['@attr-bind', $_k], this.expChanged, this]);
					this.exp_attr[$_k] = $tmp_ret[0];
					this.expChanged(null, ['@attr-bind', $_k]);
					break;
				}
				case ":key":
				{
					var $key_parts = $val.split(/\s*\,\s*/g);
					this.each_key = 'return ' + 
								(($key_parts.length > 1) ? $key_parts.join('.$val + "\\n" + ') + '.$val' : 
										$val + '.$val') + ';';
					this.each_key_obj = 'return ' + (($key_parts.length > 1) ? $key_parts.join(' + "\\n" + ') : $val) + ';';
					this.with_key = true;
					break;
				}
				default:
				{
					// alert($k + ": " + $val);
					break;
				}
			}
		}
	}
	
	test_get_data($obj)
	{
		if ($obj === undefined) $obj = this._obj;
				
		var $ret = undefined;
		if ($obj && $obj.$val)
		{
			$ret = $obj.$length ? [] : {};
			for (var $i in $obj)
			{
				if (((typeof($i) === 'string') && ($i[0] === '$')) || 
						($obj.$length && ($i === 'length')))
					continue;
				
				if (typeof($obj[$i].$val) === 'object')
					$ret[$i] = this.test_get_data($obj[$i]);
				else if ($obj[$i].$val === undefined)
				{
					// skip
				}
				else
					$ret[$i] = $obj[$i].$val;
			}
			return $ret;
		}
		else
			return undefined;		
	}
}

